function listCounter(value: objects) :: number:
    set {_num} to 0
    loop {_value::*}:
        add 1 to {_num}
    return {_num}
#                                                                                                                #
function giveNewItem(player: player, item: item, name: text, line1: text="false", line2: text="false", line3: text="false", line4: text="false", line5: text="false"):
    set {_items} to {_item} named {_name}
    if {_lore} is not "false":
        set line 1 of lore of {_items} to {_lore}
    if {_line2} is not "false":
        set line 2 of lore of {_item} to {_line2}
    if {_line3} is not "false":
        set line 3 of lore of {_item} to {_line3}
    if {_line4} is not "false":
        set line 4 of lore of {_item} to {_line4}
    if {_line5} is not "false":
        set line 5 of lore of {_item} to {_line5}
    give {_items} to {_player}
#                                                                                                                #
function formatted(text: text, player: player):
    send formatted "<insertion:%{_text}%>%{_text}%" to {_player}
#                                                                                                                #
function moneyAdd(player: player, number: integer=1, callback: boolean=false):
    set {_money} to {money.%{_player}'s uuid%}
    set {_r} to {_money} + {_number}
    set {money.%{_player}'s uuid%} to {_r}
    if {_callback} is true:
        send "[POTOR] %{_number}%₣ added to %{_player}%" to console
    logCustom("%{_number}%₣ added to %{_player}%", 4)
    logCustom("%{_number}%₣ added to %{_player}%", 5)
#                                                                                                                #
function moneyRemove(player: player, number: integer=1, callback: boolean=false):
    set {_money} to {money.%{_player}'s uuid%}
    set {_r} to {_money} - {_number}
    set {money.%{_player}'s uuid%} to {_r}
    if {_callback} is true:
        send "[POTOR] %{_number}%₣ removed from %{_player}%" to console
    logCustom("%{_number}%₣ removed from %{_player}%", 4)
    logCustom("%{_number}%₣ removed from %{_player}%", 5)
#                                                                                                                #
function sendMoney(sender: player, receiver: player, amount: integer, callback: boolean=false):
    set {_smoney} to {money.%{_sender}'s uuid%}
    set {_rmoney} to {money.%{_receiver}'s uuid%}
    set {_smoney} to {_smoney} - {_amount}
    set {_rmoney} to {_rmoney} + {_amount}
    if {_callback} is true:
        send "[POTOR] %{_sender}% send %{_amount}%₣ to %{_receiver}%" to console
    logCustom("%{_sender}% send %{_amount}%₣ to %{_receiver}%", 4)
    logCustom("%{_sender}% send %{_amount}%₣ to %{_receiver}%", 5)
#                                                                                                                #
function selector(player: player) :: text:
    set {_text} to "<tooltip:%{_player}%%nl%Type: Player%nl%%{_player}'s uuid%>%{_player}%<reset>"
    return {_text}
#                                                                                                                #
function logCustom(msg: text, lvl: integer=1):
    if {_lvl} is 1:
        send formatted "§6[§4BCK§6]§r %{_msg}%" to {log.tier1::*}
    else if {_lvl} is 2:
        send formatted "§6[§4BCK§6]§r %{_msg}%" to {log.tier2::*}
    else if {_lvl} is 3:
        send formatted "§6[§4BCK§6]§r %{_msg}%" to {log.tier3::*}
    else if {_lvl} is 4:
        send formatted "§6[§4BCK§6]§r %{_msg}%" to {log.tier4::*}
    else if {_lvl} is 5:
        send formatted "§6[§4BCK§6]§r %{_msg}%" to {log.tier5::*}
#                                                                                                                #
function fileList(dir: text, extention: text=".sk") :: objects:
    loop directory "%{_dir}%"'s files:
        if loop-value ends with "%{_extention}%":
            set {_f} to loop-value
            replace "server%{_dir}%" with "" in {_f}
            replace "/" with "" in {_f}
            add {_f} to {_files::*}
    return {_files::*}
#                                                                                                                #
function genericGui(name: text="Default Inventory", lign: integer=1, backButton: boolean=false) :: inventory:
    set {_gui} to a new chest inventory with {_lign} row named {_name}
    if {_backButton} is true:
        if {_lign} is 1:
            set slot 8 of {_gui} to barrier named "§l§4Back" with lore "§7Previous page"
        else if {_lign} is 2:
            set slot 13 of {_gui} to barrier named "§l§4Back" with lore "§7Previous page"
        else if {_lign} is 3:
            set slot 22 of {_gui} to barrier named "§l§4Back" with lore "§7Previous page"
        else if {_lign} is 3:
            set slot 31 of {_gui} to barrier named "§l§4Back" with lore "§7Previous page"
        else if {_lign} is 4:
            set slot 39 of {_gui} to barrier named "§l§4Back" with lore "§7Previous page"       
    return {_gui}
#                                                                                                                #
function materialsAdd(item: item, display: text, price: number=1):
    set {_c} to listCounter({villager.materials::*})
    broadcast {_c}
    if {_c} < 27: 
        set {_money} to numFormat("%{_price}%")
        set {_m} to "%{_item}%|%{_display}%|%{_money}%"
        add {_m} to {villager.materials::*}
    else:
        set {_money} to numFormat("%{_price}%")
        set {_m} to "%{_item}%|%{_display}%|%{_money}%"
        add {_m} to {villager.materials2::*}
#                                                                                                                #
function foodsAdd(item: item, display: text, price: number=1):
    set {_c} to listCounter({villager.materials::*})
    if {_c} < 27: 
        set {_money} to numFormat("%{_price}%")
        set {_m} to "%{_item}%|%{_display}%|%{_money}%"
        add {_m} to {villager.foods::*}
    else:
        set {_money} to numFormat("%{_price}%")
        set {_m} to "%{_item}%|%{_display}%|%{_money}%"
        add {_m} to {villager.foods2::*}

#                                                                                                                #
function potionsAdd(item: item, display: text, price: number=1):
    set {_money} to numFormat("%{_price}%")
    set {_m} to "%{_item}%|%{_display}%|%{_money}%"
    add {_m} to {villager.potions::*}
#                                                                                                                #
function constructionsAdd(item: item, display: text, price: number=1):
    set {_money} to numFormat("%{_price}%")
    set {_m} to "%{_item}%|%{_display}%|%{_money}%"
    add {_m} to {villager.constructions::*}
#                                                                                                                #
function genericItemsBlacklist(item: text, blacklist: objects) :: boolean:
    set {_v} to false
    if {_blacklist::*} contain {_item}:
        set {_v} to true
    return {_v}
#                                                                                                                #
function genericBlocksBlacklist(block: text, blacklist: objects) :: boolean:
    set {_v} to false
    if {_blacklist::*} contain {_block}:
        set {_v} to true
    return {_v}
#                                                                                                                #
function addDrawerLoreBlacklisted(lore: text):
    add {_lore} to {drawer.lore.blacklist::*}
#                                                                                                                #
function addDrawerItemBlacklisted(item: text):
    add {_item} to {drawer.item.blacklist::*}
#                                                                                                                #
function itemIsEnchanted(item: item) :: boolean:
    set {_v} to false
    if {_item} are enchanted:
        set {_v} to true
    return {_v}
#                                                                                                                #
function getDrawerLoreBlacklist() :: objects:
    return {drawer.lore.blacklist::*}
#                                                                                                                #
function getDrawerItemBlacklist() :: objects:
    return {drawer.item.blacklist::*}
#                                                                                                                #
function getCoordinateSeparate(coordinate: text, send: boolean=false) :: objects:
    set {_list::*} to split "%{_coordinate}%" by ","
    set {_li::*} to split "%{_coordinate}%" by "in"
    loop {_li::*}:
        if loop-index is "2":
            set {_vv} to loop-value
            replace " " with "" in {_vv}
            loop 2 times:
                replace "'" with "" in {_vv}
            set {_w} to {_vv}
    loop {_list::*}:
        if loop-value contain "x:":
            set {_v} to loop-value
            replace "x: " with "" in {_v}
            set {_x} to {_v}
        else if loop-value contain "y:":
            set {_v} to loop-value
            replace " y: " with "" in {_v}
            set {_y} to {_v}
        else if loop-value contain "z:":
            set {_v} to loop-value
            replace " z: " with "" in {_v}
            set {_z} to {_v}
    replace ".5" with "" in {_x}
    replace ".5" with "" in {_y}
    replace ".5" with "" in {_z}
    add {_x} parsed as number to {_r::*}
    add {_y} parsed as number to {_r::*}
    add {_z} parsed as number to {_r::*}
    add {_w} to {_r::*}
    if {_send} is true:
        broadcast "X: %{_x}% / Y: %{_y}% / Z: %{_z}%"
    return {_r::*}
#                                                                                                                #
function getX(coordinate: objects) :: integer:
    loop {_coordinate::*}:
        if loop-index is "1":
            set {_r} to loop-value
            #broadcast "%loop-value% | %loop-index%"
    return {_r}
#                                                                                                                #
function getY(coordinate: objects) :: integer:
    loop {_coordinate::*}:
        if loop-index is "2":
            set {_r} to loop-value
    return {_r}
#                                                                                                                #
function getZ(coordinate: objects) :: integer:
    loop {_coordinate::*}:
        if loop-index is "3":
            set {_r} to loop-value
    return {_r}
#                                                                                                                #
function getWorld(coordinate: objects) :: text:
    loop {_coordinate::*}:
        if loop-index is "4":
            set {_r} to loop-value
    return {_r}
#                                                                                                                #
function addGeneratorType(type: text, item: text="iron block", name: text, lores: objects):
    add {_type} to {generators.types::*}
    set {_i} to {_item} parsed as item type named {_name}
    loop {_lores::*}:
        set {_n} to loop-index parsed as integer
        set line {_n} of lore of {_i} to "%loop-value%"
    set {generators.types::%{_type}%.item} to {_i}
#                                                                                                                #
function getGeneratorTypes() :: objects:
    set {_r::*} to {generators.types::*}
    loop {_r::*}:
        set {_v} to uncolored loop-value
        set {_n} to uncolored {_name}
        replace "%{_item} named {_n}%" with "" in {_v}
        add {_v} to {_rr::*}
    return {_rr::*}
#                                                                                                                #
function getGeneratorItems() :: objects:
    set {_r::*} to getGeneratorTypes()
    loop {_r::*}:
        set {_t} to loop-value
        set {_i} to {generators.types::%{_t}%.item}
        add {_i} to {_i::*}
    #broadcast {_i::*}
    return {_i::*}
#                                                                                                                #
function giveGeneratorItem(player: player, type: text):
    set {_types::*} to getGeneratorTypes()
    set {_v} to false
    loop {_types::*}:
        if loop-value is {_type}:
            set {_v} to true
    if {_v} is true:
        set {_item} to {generators.types::%{_type}%.item}
        give {_item} to {_player}
        play sound "entity.item.pickup" with volume 0.3 at {_player}
#                                                                                                                #
function drawerDropAtLocation(u: block, name: text, player: player, location: location):
    set {_l1} to line 1 of {_u}
    set {_l2} to line 2 of {_u}
    set {_l3} to line 3 of {_u}
    set {_l4} to line 4 of {_u}
    if {_l1} is {_name}:
        if {_player}'s gamemode is creative:
            wait 3 ticks
            if {_l1} is set:
                set line 1 of {_u} to {_l1}
            if {_l2} is set:
                set line 2 of {_u} to {_l2}
            if {_l3} is set:
                set line 3 of {_u} to {_l3}
            if {_l4} is set:
                set line 4 of {_u} to {_l4}
        else:
            if {_l2} is set:
                set {_i} to "%{_l2}%" parsed as item
            if {_l3} is set:
                set {_n} to "%{_l3}%" parsed as integer
            if {_l4} is set:
                set {_p} to {_l4} parsed as player
            loop {_n} times:
                drop {_i} at {_location}
            #send "%{_l1}% | %{_l2}% | %{_l3}% | %{_l4}%" to {_player}
            logCustom("--> %{_l1}%§r %{_l3}% %{_l2}% dropped for %selector({_p})%", 5)
#                                                                                                                #
function addSellers(category: text, name: text):
    add "%{_category}%/%{_name}%" to {sellers::*}
#                                                                                                                #
function getSellers(name: boolean=true, uncolored: boolean=false) :: objects:
    loop {sellers::*}:
        set {_v} to loop-value
        set {_ss::*} to split {_v} by "/"
        set {_t1} to {_ss::1}
        set {_t2} to {_ss::2}

        if {_name} is true:
            if {_uncolored} is true:
                add uncolored {_t2} to {_r::*}
            else:
                add {_t2} to {_r::*}
        else:
            if {_uncolored} is true:
                add uncolored {_t1} to {_r::*}
            else:
                add {_t1} to {_r::*}
        #broadcast {_s::%{_t2}%::*}
    #broadcast {_r}
    return {_r::*}    
#                                                                                                                #
function textToMinecraft(text: text) :: text:
    replace all " " with "_" in {_text}
    return {_text}
#                                                                                                                #
function mobNbtEdit(p: player, mob: text, data: text, value: text):
    set {_en} to textToMinecraft({_mob})
    make console execute command "/execute at %{_p}% run data modify entity @e[type=%{_en}%,limit=1,distance=..1] %{_data}% set value %{_value}%"
#                                                                                                                #
function numberFormatter(num: integer) :: text:
    if length of {_b} > 3:
        set {_a} to "%a(first length of {_b} - 3 characters of {_b})%,%last 3 characters of {_b}%"
                
    return {_a}
#                                                                                                                #
function a(b: text) :: text:
  if length of {_b} > 3:
    return "%a(first length of {_b} - 3 characters of {_b})%,%last 3 characters of {_b}%"
  return {_b}
#                                                                                                                #
function numFormat(i: text) :: text:
    #broadcast {_i}
    if {_i} is not "0":
        set {_r} to ""
        set {_l} to {_i}' length
        loop {_l} times:
            set {_r} to "%subtext of {_i} from {_l}-loop-value+1 to {_l}-loop-value+1%%{_r}%"
            if mod(loop-value, 3) is equal to 0:
                if loop-value is not {_l}:
                    set {_r} to ".%{_r}%"
    else:
        set {_r} to "0"
    return {_r}
#                                                                                                                #
function switchCaseFor(text: text, to-uppercase: boolean) :: text:
 
    set {_characters::*} to {_text} split at ""
    set {_new} to ""
 
    loop {_characters::*}:
 
        set {_char} to loop-value
 
        if {_to-uppercase} is true:
            set {_char} to {letters::uppercase::%loop-value%}
        else:
            set {_char} to {letters::lowercase::%loop-value%}
 
        set {_new} to "%{_new}%%{_char}%"
 
    return {_new}
#                                                                                                                #
function uppercase(text: text) :: text:
 
    return switchCaseFor({_text}, true)
#                                                                                                                #
function lowercase(text: text) :: text:
 
    return switchCaseFor({_text}, false)
#                                                                                                                # 
function capitalize(text: text) :: text:
 
    set {_char} to the first character of {_text}
    set {_char} to {letters::uppercase::%{_char}%}
 
    set {_remaining} to ""
    set {_remaining} to the last (length of {_text} - 1) characters of {_text}
 
    return "%{_char}%%{_remaining}%"
#                                                                                                                #
function glassAdd(gui: inventory, type: number=1) :: inventory:
    if {_type} = 2:
        set {_slot} to 0
        loop 27 times:
            if {_slot} = 10:
                add 7 to {_slot}
            else if {_slot} = 19:
                add 7 to {_slot}
            else if {_slot} = 28:
                add 7 to {_slot}
            else if {_slot} = 38:
                add 6 to {_slot}
            set slot {_slot} of {_gui} to black stained glass pane
            add 1 to {_slot}
    else if {_type} = 1:
        set {_slot} to 0
        loop 26 times:
            if {_slot} = 10:
                add 7 to {_slot}
            else if {_slot} = 19:
                add 7 to {_slot}
            else if {_slot} = 28:
                add 7 to {_slot}
            else if {_slot} = 37:
                add 6 to {_slot}
            set slot {_slot} of {_gui} to black stained glass pane
            add 1 to {_slot}
    else:
        set {_slot} to 0
        loop 27 times:
            if {_slot} = 10:
                add 7 to {_slot}
            else if {_slot} = 19:
                add 7 to {_slot}
            else if {_slot} = 28:
                add 7 to {_slot}
            else if {_slot} = 38:
                add 5 to {_slot}
            set slot {_slot} of {_gui} to black stained glass pane
            add 1 to {_slot}
#                                                                                                                #
function itemsAdd(gui: inventory, list: objects) :: inventory:
    loop {_list::*}:
        set {_data::*} to loop-value split by "|"
        set {_item} to {_data::1} parsed as item
        set {_name} to {_data::2}
        set {_price} to getPrice({_data::3})
        set {_money} to numFormat("%{_price}%")        
        loop 45 times:
            set {_slot} to loop-number

            if slot {_slot} of {_gui} is air:
                set {_ii} to {_item} named "%{_name}% §7%{_money}%%{sbm}%"
                set line 1 of lore of {_ii} to "§aLeft click to buy§r"
                set line 2 of lore of {_ii} to "§4Right click to sell§r"
                set slot {_slot} of {_gui} to {_ii}
                exit loop
function getPrice(str: text) :: number:
    replace all "." with "" in {_str}
    set {_price} to {_str} parsed as number
    return {_price}
function getItemFromList(loop: objects) :: objects:
    loop {_loop::*}:
        set {_data::*} to loop-value split by "|"
        add uncolored {_data::2} to {_list::*}
    return {_list::*}
function giveObjectsItem(list: objects, item: item, player: player):
    loop {_list::*}:
        set {_data::*} to loop-value split by "|"
        set {_ii} to {_data::1} parsed as item
        set {_name} to {_data::2}
        set {_price} to getPrice({_data::3})
        set {_money} to numFormat("%{_price}%")
        set {_pm} to {money.%{_player}'s uuid%}
        if {_item} is {_ii}:
            if {_pm} >= {_price}:
                moneyRemove({_player}, {_price}, true)
                give {_ii} to {_player}
                set {_s} to selector({_player})
                logCustom("§7%{_s}%§r just bought 1 §7%{_ii}%", 4)
                logCustom("§7%{_s}%§r just bought 1 §7%{_ii}%", 5)
                play sound "entity.villager.trade" with volume 0.5 at {_player}
                exit loop
            else:
                play sound "entity.villager.no" with volume 0.5 at {_player}
                exit loop
function removeObjectsItem(list: objects, item: item, player: player):
    loop {_list::*}:
        set {_data::*} to loop-value split by "|"
        set {_ii} to {_data::1} parsed as item
        set {_name} to {_data::2}
        set {_price} to getPrice({_data::3})
        set {_money} to numFormat("%{_price}%")
        set {_pm} to {money.%{_player}'s uuid%}
        set {_amount} to amount of {_ii} in {_player}'s inventory
        if {_item} is {_ii}:
            if {_amount} >= 1:
                if {_price} is not 1:
                    set {_rr} to {_price} / 1.75
                    set {_rr} to ceil({_rr})
                else:
                    set {_rr} to {_price}
                moneyAdd({_player}, {_rr}, true)
                remove {_ii} from {_player}'s inventory
                logCustom("§7%selector({_player})%§r just sell 1 §7%{_ii}%", 4)
                logCustom("§7%selector({_player})%§r just sell 1 §7%{_ii}%", 5)
                play sound "entity.villager.trade" with volume 0.5 at {_player}
                exit loop
            else:
                play sound "entity.villager.no" with volume 0.5 at {_player}
                exit loop
function clanRankAdd(name: text):
    if {_name} is set:
        add {_name} to {clan.ranks::*}
function getClanRank() :: objects:
    loop {clan.ranks::*}:
        add loop-value to {_list::*}
    return {_list::*}